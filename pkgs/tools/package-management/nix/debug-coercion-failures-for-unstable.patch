commit bd3318b3f07660f57acbdeea2af599e35243154c
Author: Marc Weber <marco-oweber@gmx.de>
Date:   Mon Oct 22 01:26:48 2012 +0200

    experimental/debug-coercions-as-xml
    
    We're all pretty helpless seeing messages like:
    
      value is an attribute set while a list was expected
    
    This patch add sthe flag --xml-debug-coercion-failure
    making nix output the xml representation of the attribute set
    - which of course may fail eg if infinite recursions are used.
    However its more often useful than failing.
    
    Signed-off-by: Marc Weber <marco-oweber@gmx.de>

diff --git a/src/libexpr/eval-inline.hh b/src/libexpr/eval-inline.hh
index 57a9e4c..d114e64 100644
--- a/src/libexpr/eval-inline.hh
+++ b/src/libexpr/eval-inline.hh
@@ -42,7 +42,7 @@ inline void EvalState::forceAttrs(Value & v)
 {
     forceValue(v);
     if (v.type != tAttrs)
-        throwTypeError("value is %1% while an attribute set was expected", showType(v));
+        throwTypeError("value is %1% while an attribute set was expected", showTypeOrXml(v));
 }
 
 
@@ -50,7 +50,7 @@ inline void EvalState::forceList(Value & v)
 {
     forceValue(v);
     if (v.type != tList)
-        throwTypeError("value is %1% while a list was expected", showType(v));
+        throwTypeError("value is %1% while a list was expected", showTypeOrXml(v));
 }
 
 }
diff --git a/src/libexpr/eval.cc b/src/libexpr/eval.cc
index 2f9601e..c4f9abf 100644
--- a/src/libexpr/eval.cc
+++ b/src/libexpr/eval.cc
@@ -4,6 +4,7 @@
 #include "store-api.hh"
 #include "derivations.hh"
 #include "globals.hh"
+#include "value-to-xml.hh"
 #include "eval-inline.hh"
 
 #include <cstring>
@@ -205,6 +206,18 @@ void EvalState::addConstant(const string & name, Value & v)
 }
 
 
+string EvalState::showTypeOrXml(Value &v){
+    if (xmldebugCorcionFailure){
+        // make running this code intsead optional
+        std::ostringstream out;
+        PathSet context;
+        printValueAsXML(*this, true, false, v, out, context);
+        return out.str(); // don't know whether this is safe !
+    } else {
+        return showType(v);
+    }
+}
+
 void EvalState::addPrimOp(const string & name,
     unsigned int arity, PrimOpFun primOp)
 {
@@ -453,7 +466,7 @@ inline bool EvalState::evalBool(Env & env, Expr * e)
     Value v;
     e->eval(*this, env, v);
     if (v.type != tBool)
-        throwTypeError("value is %1% while a Boolean was expected", showType(v));
+        throwTypeError("value is %1% while a Boolean was expected", showTypeOrXml(v));
     return v.boolean;
 }
 
@@ -462,7 +475,7 @@ inline void EvalState::evalAttrs(Env & env, Expr * e, Value & v)
 {
     e->eval(*this, env, v);
     if (v.type != tAttrs)
-        throwTypeError("value is %1% while an attribute set was expected", showType(v));
+        throwTypeError("value is %1% while an attribute set was expected", showTypeOrXml(v));
 }
 
 
@@ -726,7 +739,7 @@ void EvalState::callFunction(Value & fun, Value & arg, Value & v)
     
     if (fun.type != tLambda)
         throwTypeError("attempt to call something which is not a function but %1%",
-            showType(fun));
+            showTypeOrXml(fun));
 
     unsigned int size =
         (fun.lambda.fun->arg.empty() ? 0 : 1) +
@@ -1000,7 +1013,7 @@ int EvalState::forceInt(Value & v)
 {
     forceValue(v);
     if (v.type != tInt)
-        throwTypeError("value is %1% while an integer was expected", showType(v));
+        throwTypeError("value is %1% while an integer was expected", showTypeOrXml(v));
     return v.integer;
 }
 
@@ -1009,7 +1022,7 @@ bool EvalState::forceBool(Value & v)
 {
     forceValue(v);
     if (v.type != tBool)
-        throwTypeError("value is %1% while a Boolean was expected", showType(v));
+        throwTypeError("value is %1% while a Boolean was expected", showTypeOrXml(v));
     return v.boolean;
 }
 
@@ -1018,7 +1031,7 @@ void EvalState::forceFunction(Value & v)
 {
     forceValue(v);
     if (v.type != tLambda && v.type != tPrimOp && v.type != tPrimOpApp)
-        throwTypeError("value is %1% while a function was expected", showType(v));
+        throwTypeError("value is %1% while a function was expected", showTypeOrXml(v));
 }
 
 
@@ -1026,7 +1039,7 @@ string EvalState::forceString(Value & v)
 {
     forceValue(v);
     if (v.type != tString)
-        throwTypeError("value is %1% while a string was expected", showType(v));
+        throwTypeError("value is %1% while a string was expected", showTypeOrXml(v));
     return string(v.string.s);
 }
 
@@ -1107,7 +1120,7 @@ string EvalState::coerceToString(Value & v, PathSet & context,
     if (v.type == tAttrs) {
         Bindings::iterator i = v.attrs->find(sOutPath);
         if (i == v.attrs->end())
-            throwTypeError("cannot coerce an attribute set (except a derivation) to a string");
+            throwTypeError("cannot coerce an attribute set: %1% (except a derivation) to a string", showTypeOrXml(v));
         return coerceToString(*i->value, context, coerceMore, copyToStore);
     }
 
@@ -1134,7 +1147,7 @@ string EvalState::coerceToString(Value & v, PathSet & context,
         }
     }
     
-    throwTypeError("cannot coerce %1% to a string", showType(v));
+    throwTypeError("cannot coerce %1% to a string", showTypeOrXml(v));
 }
 
 
@@ -1220,7 +1233,7 @@ bool EvalState::eqValues(Value & v1, Value & v2)
             return false;
 
         default:
-            throwEvalError("cannot compare %1% with %2%", showType(v1), showType(v2));
+            throwEvalError("cannot compare %1% with %2%", showTypeOrXml(v1), showTypeOrXml(v2));
     }
 }
 
diff --git a/src/libexpr/eval.hh b/src/libexpr/eval.hh
index a3c55a3..c737b09 100644
--- a/src/libexpr/eval.hh
+++ b/src/libexpr/eval.hh
@@ -205,6 +205,8 @@ private:
     void addPrimOp(const string & name,
         unsigned int arity, PrimOpFun primOp);
 
+    string showTypeOrXml(Value &v);
+
     inline Value * lookupVar(Env * env, const VarRef & var);
     
     friend class ExprVar;
diff --git a/src/libmain/shared.cc b/src/libmain/shared.cc
index 9e5964a..261352e 100644
--- a/src/libmain/shared.cc
+++ b/src/libmain/shared.cc
@@ -196,6 +196,9 @@ static void initAndRun(int argc, char * * argv)
             settings.useBuildHook = false;
         else if (arg == "--show-trace")
             showTrace = true;
+        else if (arg == "--xml-debug-coercion-failure") {
+            xmldebugCorcionFailure = true;
+        }
         else if (arg == "--option") {
             ++i; if (i == args.end()) throw UsageError("`--option' requires two arguments");
             string name = *i;
diff --git a/src/libstore/globals.cc b/src/libstore/globals.cc
index 9b22d54..96829ff 100644
--- a/src/libstore/globals.cc
+++ b/src/libstore/globals.cc
@@ -22,6 +22,7 @@ Settings::Settings()
     maxBuildJobs = 1;
     buildCores = 1;
     readOnlyMode = false;
+    xmldebugCorcionFailure = false;
     thisSystem = SYSTEM;
     maxSilentTime = 0;
     buildTimeout = 0;
diff --git a/src/libstore/globals.hh b/src/libstore/globals.hh
index d25ee6a..6776134 100644
--- a/src/libstore/globals.hh
+++ b/src/libstore/globals.hh
@@ -78,6 +78,12 @@ struct Settings {
        the database. */
     bool readOnlyMode;
 
+
+    /* if set to true nix will print the value it tried to coerce to a
+     particular type as xml. This printing may trigger infitie recursions
+     in soem cases - thus use for debugging only */
+    bool xmldebugCorcionFailure;
+
     /* The canonical system name, as returned by config.guess. */
     string thisSystem;
 
diff --git a/src/nix-instantiate/nix-instantiate.cc b/src/nix-instantiate/nix-instantiate.cc
index ab0c8cf..5f27d68 100644
--- a/src/nix-instantiate/nix-instantiate.cc
+++ b/src/nix-instantiate/nix-instantiate.cc
@@ -96,6 +96,9 @@ void run(Strings args)
             settings.readOnlyMode = true;
             evalOnly = true;
         }
+        else if (arg == "--xml-debug-coercion-failure") {
+            xmldebugCorcionFailure = true;
+        }
         else if (arg == "--parse-only") {
             settings.readOnlyMode = true;
             parseOnly = evalOnly = true;
