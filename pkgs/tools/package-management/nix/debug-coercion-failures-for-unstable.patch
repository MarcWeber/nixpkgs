commit 37453f6d95f4f62a45f382ba759bbf6d4409dea3
Author: Marc Weber <marco-oweber@gmx.de>
Date:   Sun Aug 26 19:19:17 2012 +0200

    experimental/debug-coercions-as-xml
    
    We're all pretty helpless seeing messages like:
    
      value is an attribute set while a list was expected
    
    This patch add sthe flag --xml-debug-coercion-failure
    making nix output the xml representation of the attribute set
    - which of course may fail eg if infinite recursions are used.
    However its more often useful than failing.
    
    Signed-off-by: Marc Weber <marco-oweber@gmx.de>

diff --git a/src/libexpr/eval-inline.hh b/src/libexpr/eval-inline.hh
index 57a9e4c..d114e64 100644
--- a/src/libexpr/eval-inline.hh
+++ b/src/libexpr/eval-inline.hh
@@ -42,7 +42,7 @@ inline void EvalState::forceAttrs(Value & v)
 {
     forceValue(v);
     if (v.type != tAttrs)
-        throwTypeError("value is %1% while an attribute set was expected", showType(v));
+        throwTypeError("value is %1% while an attribute set was expected", showTypeOrXml(v));
 }
 
 
@@ -50,7 +50,7 @@ inline void EvalState::forceList(Value & v)
 {
     forceValue(v);
     if (v.type != tList)
-        throwTypeError("value is %1% while a list was expected", showType(v));
+        throwTypeError("value is %1% while a list was expected", showTypeOrXml(v));
 }
 
 }
diff --git a/src/libexpr/eval.cc b/src/libexpr/eval.cc
index fadfb3b..58b47b4 100644
--- a/src/libexpr/eval.cc
+++ b/src/libexpr/eval.cc
@@ -1,9 +1,10 @@
-#include "eval.hh"
+#include "eval.hh"
 #include "hash.hh"
 #include "util.hh"
 #include "store-api.hh"
 #include "derivations.hh"
 #include "globals.hh"
+#include "value-to-xml.hh"
 #include "eval-inline.hh"
 
 #include <cstring>
@@ -204,6 +205,18 @@ void EvalState::addConstant(const string & name, Value & v)
 }
 
 
+string EvalState::showTypeOrXml(Value &v){
+    if (xmldebugCorcionFailure){
+        // make running this code intsead optional
+        std::ostringstream out;
+        PathSet context;
+        printValueAsXML(*this, true, false, v, out, context);
+        return out.str(); // don't know whether this is safe !
+    } else {
+        return showType(v);
+    }
+}
+
 void EvalState::addPrimOp(const string & name,
     unsigned int arity, PrimOpFun primOp)
 {
@@ -452,7 +465,7 @@ inline bool EvalState::evalBool(Env & env, Expr * e)
     Value v;
     e->eval(*this, env, v);
     if (v.type != tBool)
-        throwTypeError("value is %1% while a Boolean was expected", showType(v));
+        throwTypeError("value is %1% while a Boolean was expected", showTypeOrXml(v));
     return v.boolean;
 }
 
@@ -461,7 +474,7 @@ inline void EvalState::evalAttrs(Env & env, Expr * e, Value & v)
 {
     e->eval(*this, env, v);
     if (v.type != tAttrs)
-        throwTypeError("value is %1% while an attribute set was expected", showType(v));
+        throwTypeError("value is %1% while an attribute set was expected", showTypeOrXml(v));
 }
 
 
@@ -725,7 +738,7 @@ void EvalState::callFunction(Value & fun, Value & arg, Value & v)
     
     if (fun.type != tLambda)
         throwTypeError("attempt to call something which is not a function but %1%",
-            showType(fun));
+            showTypeOrXml(fun));
 
     unsigned int size =
         (fun.lambda.fun->arg.empty() ? 0 : 1) +
@@ -999,7 +1012,7 @@ int EvalState::forceInt(Value & v)
 {
     forceValue(v);
     if (v.type != tInt)
-        throwTypeError("value is %1% while an integer was expected", showType(v));
+        throwTypeError("value is %1% while an integer was expected", showTypeOrXml(v));
     return v.integer;
 }
 
@@ -1008,7 +1021,7 @@ bool EvalState::forceBool(Value & v)
 {
     forceValue(v);
     if (v.type != tBool)
-        throwTypeError("value is %1% while a Boolean was expected", showType(v));
+        throwTypeError("value is %1% while a Boolean was expected", showTypeOrXml(v));
     return v.boolean;
 }
 
@@ -1017,7 +1030,7 @@ void EvalState::forceFunction(Value & v)
 {
     forceValue(v);
     if (v.type != tLambda && v.type != tPrimOp && v.type != tPrimOpApp)
-        throwTypeError("value is %1% while a function was expected", showType(v));
+        throwTypeError("value is %1% while a function was expected", showTypeOrXml(v));
 }
 
 
@@ -1025,7 +1038,7 @@ string EvalState::forceString(Value & v)
 {
     forceValue(v);
     if (v.type != tString)
-        throwTypeError("value is %1% while a string was expected", showType(v));
+        throwTypeError("value is %1% while a string was expected", showTypeOrXml(v));
     return string(v.string.s);
 }
 
@@ -1106,7 +1119,7 @@ string EvalState::coerceToString(Value & v, PathSet & context,
     if (v.type == tAttrs) {
         Bindings::iterator i = v.attrs->find(sOutPath);
         if (i == v.attrs->end())
-            throwTypeError("cannot coerce an attribute set (except a derivation) to a string");
+            throwTypeError("cannot coerce an attribute set: %1% (except a derivation) to a string", showTypeOrXml(v));
         return coerceToString(*i->value, context, coerceMore, copyToStore);
     }
 
@@ -1133,7 +1146,7 @@ string EvalState::coerceToString(Value & v, PathSet & context,
         }
     }
     
-    throwTypeError("cannot coerce %1% to a string", showType(v));
+    throwTypeError("cannot coerce %1% to a string", showTypeOrXml(v));
 }
 
 
@@ -1219,7 +1232,7 @@ bool EvalState::eqValues(Value & v1, Value & v2)
             return false;
 
         default:
-            throwEvalError("cannot compare %1% with %2%", showType(v1), showType(v2));
+            throwEvalError("cannot compare %1% with %2%", showTypeOrXml(v1), showTypeOrXml(v2));
     }
 }
 
diff --git a/src/libexpr/eval.hh b/src/libexpr/eval.hh
index a1f26a0..ef3d1a8 100644
--- a/src/libexpr/eval.hh
+++ b/src/libexpr/eval.hh
@@ -201,6 +201,8 @@ private:
     void addPrimOp(const string & name,
         unsigned int arity, PrimOpFun primOp);
 
+    string showTypeOrXml(Value &v);
+
     inline Value * lookupVar(Env * env, const VarRef & var);
     
     friend class ExprVar;
diff --git a/src/libmain/shared.cc b/src/libmain/shared.cc
index 026db41..751ad67 100644
--- a/src/libmain/shared.cc
+++ b/src/libmain/shared.cc
@@ -188,6 +188,9 @@ static void initAndRun(int argc, char * * argv)
             useBuildHook = false;
         else if (arg == "--show-trace")
             showTrace = true;
+        else if (arg == "--xml-debug-coercion-failure") {
+            xmldebugCorcionFailure = true;
+        }
         else if (arg == "--option") {
             ++i; if (i == args.end()) throw UsageError("`--option' requires two arguments");
             string name = *i;
diff --git a/src/libstore/globals.cc b/src/libstore/globals.cc
index 5c22f14..4baf982 100644
--- a/src/libstore/globals.cc
+++ b/src/libstore/globals.cc
@@ -26,6 +26,7 @@ Verbosity buildVerbosity = lvlError;
 unsigned int maxBuildJobs = 1;
 unsigned int buildCores = 1;
 bool readOnlyMode = false;
+bool xmldebugCorcionFailure = false;
 string thisSystem = "unset";
 time_t maxSilentTime = 0;
 time_t buildTimeout = 0;
diff --git a/src/libstore/globals.hh b/src/libstore/globals.hh
index 1c0877a..967c1db 100644
--- a/src/libstore/globals.hh
+++ b/src/libstore/globals.hh
@@ -113,7 +113,13 @@ void overrideSetting(const string & name, const Strings & value);
 
 void reloadSettings();
 
-void setDefaultsFromEnvironment();
 
+/* if set to true this prints the type which nix tried to coerce to a non matching type
+ * printing the xml can lead to infinite recursions etc.. So this is for
+ * debugging your Nix code only
+ */
+extern bool xmldebugCorcionFailure;
+
+void setDefaultsFromEnvironment();
 
 }
diff --git a/src/nix-instantiate/nix-instantiate.cc b/src/nix-instantiate/nix-instantiate.cc
index bca65d0..3c11f0a 100644
--- a/src/nix-instantiate/nix-instantiate.cc
+++ b/src/nix-instantiate/nix-instantiate.cc
@@ -99,6 +99,9 @@ void run(Strings args)
             readOnlyMode = true;
             evalOnly = true;
         }
+        else if (arg == "--xml-debug-coercion-failure") {
+            xmldebugCorcionFailure = true;
+        }
         else if (arg == "--parse-only") {
             readOnlyMode = true;
             parseOnly = evalOnly = true;
